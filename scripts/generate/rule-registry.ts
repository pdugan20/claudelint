/**
 * Auto-generate rule registry from schema metadata
 * Extracts rule IDs and metadata from Zod schemas and generates src/rules/index.ts
 *
 * Usage: npm run generate:rule-registry
 */
import { writeFile } from 'fs/promises';
import { join } from 'path';
import * as glob from 'glob';
import { promisify } from 'util';

const globAsync = promisify(glob.glob);

interface RuleMetadata {
  id: string;
  name: string;
  description: string;
  category: string;
  severity: 'error' | 'warning';
  fixable: boolean;
  since: string;
}

/**
 * Parse schema files and extract rule metadata
 * TODO: Implement in Phase 2 after schemas are created
 */
async function extractRulesFromSchemas(): Promise<RuleMetadata[]> {
  const schemaFiles = await globAsync('src/schemas/*.schema.ts');
  const rules: RuleMetadata[] = [];

  // TODO Phase 2: Parse each schema file for .refine(), .max(), .min(), etc.
  // and extract rule metadata from error messages

  console.log(`Found ${schemaFiles.length} schema files`);
  console.log('TODO: Implement schema parsing in Phase 2');

  return rules;
}

/**
 * Generate src/rules/index.ts from rule metadata
 */
async function generateRuleRegistry(rules: RuleMetadata[]): Promise<void> {
  let content = `/**
 * Centralized rule registration for all validators
 * AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated by: scripts/generate-rule-registry.ts
 * Run: npm run generate:rule-registry
 */

import { RuleRegistry } from '../utils/rule-registry';

`;

  // Group by category
  const byCategory = new Map<string, RuleMetadata[]>();
  for (const rule of rules) {
    if (!byCategory.has(rule.category)) {
      byCategory.set(rule.category, []);
    }
    byCategory.get(rule.category)!.push(rule);
  }

  // Generate registration code
  for (const [category, categoryRules] of byCategory) {
    content += `/**\n * ${category} Validator Rules\n */\n`;

    for (const rule of categoryRules) {
      content += `RuleRegistry.register({
  id: '${rule.id}',
  name: '${rule.name}',
  description: '${rule.description}',
  category: '${rule.category}',
  severity: '${rule.severity}',
  fixable: ${rule.fixable},
  deprecated: false,
  since: '${rule.since}',
});

`;
    }
  }

  const outputPath = join(process.cwd(), 'src/rules/index.ts');
  await writeFile(outputPath, content);

  console.log(`[SUCCESS] Generated ${rules.length} rule registrations`);
  console.log(`   Output: ${outputPath}`);
}

/**
 * Main execution
 */
async function main() {
  console.log('[BUILD] Generating rule registry from schemas...\n');

  const rules = await extractRulesFromSchemas();

  if (rules.length === 0) {
    console.log('[WARN] No rules found. Schemas not yet created.');
    console.log('   This is expected in Phase 1.');
    console.log('   Registry generation will work in Phase 2 after schemas are defined.\n');
    process.exit(0);
  }

  await generateRuleRegistry(rules);

  console.log('\n[SUCCESS] Rule registry generation complete!');
}

main().catch((error) => {
  console.error('[FAIL] Error generating rule registry:', error);
  process.exit(1);
});
